# 拷贝 赋值与销毁

## 拷贝构造函数

```c++
class Foo{
    Foo(); //默认构造函数
    Foo(const Foo&); //拷贝构造函数
};
```

* 拷贝构造函数的第一个参数必须是一个引用类型。
* 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数： 将其参数的成员（非static成员）逐个拷贝到正在创建的对象中。

### 拷贝初始化

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生：

* 将一个对象作为实参传递给一个非引用类型的形参。
* 从一个返回类型为非引用类型的函数返回一个对象。
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
* 某些类类型还会对它们所分配的对象使用拷贝初始化。如：容器中insert或push成员，会对其元素进行拷贝初始化。相对，emplace成员创建的元素都是进行直接初始化。

### 参数和返回值

* 拷贝构造函数的参数必须为引用类型:拷贝构造函数被用来初始化非引用类型参数，自身若为非引用类型参数，则为了拷贝实参，我们需要调用拷贝构造函数，如此陷入无限循环。

### 拷贝初始化的限制

如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就无关紧要了。
```c++
vector<int> v1(10); //直接初始化
vector<int> v2 = 10; //错误：接受大小参数的构造函数是explicit的
void f(vector<int>); //f的参数进行拷贝初始化
f(10); //错误：不能用一个explicit的构造函数拷贝一个实参
f(vector<int>(10)); //正确：从一个int直接构造一个临时vector
```

## 拷贝赋值运算符

* 与控制其对象如何初始化一样，类也可以控制其对象如何赋值。

* 与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

### 重载赋值运算符

```c++
Foo& operator=(const F00&); //赋值运算符
```
> 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

### 合成拷贝赋值运算符

* 与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个合成拷贝赋值运算符：将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。

## 析构函数

析构函数释放对象使用的资源，并销毁对象的非static数据成员。
```c++
~Foo(); //析构函数
```
> 由于析构函数不接受参数，因此它不能被重载。对一个给定的类，只会有唯一一个析构函数。

* 在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

* 在一个析构函数中，不存在类似构造函数中的初始化列表的东西来控制成员如何销毁，析构部分是隐式的。

* 隐式销毁一个内置指针裂隙的成员不会delete它所指向的对象。与普通指针不同，智能指针是类类型，具有析构函数，智能指针成员在析构阶段会被自动销毁。

### 什么时候会调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数：
* 变量在离开其作用域时被销毁。

* 当一个对象被销毁时，其成员被销毁。

* 容器被销毁时，其元素被销毁。

* 对于动态分配的对象，当对指向它的指针应用delete运算符时被小虎。

* 对于临时对象，当创建它的完整表达式结束时被销毁。

> 由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放这些资源。

### 合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。 合成析构函数的函数体为空。

> 析构函数体自身并不直接销毁成员，成员是在析构函数体之后的隐含的析构阶段中被销毁的。在整个过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

## 三/五法则

有三个基本操作可以控制类的拷贝操作： 拷贝钩爪函数， 拷贝赋值运算符和析构函数。 新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。

* 需要析构函数的类也需要拷贝和赋值操作。

* 需要拷贝操作的类也需要赋值操作，反之亦然。

### 使用=default来显示地要求编译器生成合成的版本。

## 阻止拷贝

对某些类，拷贝构造函数和拷贝赋值运算符没有合理的意义。在这种情况下，定义类时必须采用某中机制阻止拷贝或赋值。 如iostream类阻止拷贝，以避免多个对象写入或读取相同的IO缓冲。

### 定义删除函数

使用=delete通知编译器，我们不希望定义这些成员。（不使用编译器可能自动生成合成的版本)
与=default不同：
* =delete必须出现在函数第一次声明的时候。

* 我们可以对任何函数指定=delete。（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default)

### 析构函数不能是删除的成员

* 如果析构函数被删除，就无法销毁此类型的对象了。

* 对与一个删除了析构函数的类型 ，编译器将不允许定义该类型的变量或创建该类的临时对象。

* 对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。

### 合成的拷贝控制成员可能是删除的

对某些类来说，编译器将这些合成的成员定义为删除的函数：

* 如果类的某个成员的析构函数是删除的或不可访问的（例如：private的），则类的合成析构函数 和 合成拷贝构造函数 被定义为删除的。

* 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。

* 如果类的某个成员的拷贝赋值运算符是删除或不可访问的，或是类有一个const/引用成员，则类的合成拷贝赋值运算符被定义为删除的。

* 如果类的某个成员的析构函数是删除或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。

> 总的来说： 如果一个类的数据成员不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的。

### private 拷贝控制

* 拷贝构造函数和拷贝赋值运算符为private的，用户代码不能拷贝这个类型的对象。但是，友元和成员函数依旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们。

* 通过声明(但不定义)private 的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。

> 建议阻止拷贝时使用 =delete 来定义拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的。

## 拷贝控制和资源管理

为定义类的成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或像一个指针。

类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本也不会改变原对象，反之亦然。

行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

> HasPtr类有两个成员，一个int和一个string指针。我们如何拷贝指针成员决定了像HasPtr这样的类是具有类值行为还是类指针行为。

### 行为像值的类

```c++
class HasPtr{
public:
    HasPtr(const  string &s = string()):ps(new std::string(s)),i(0){};
    //对ps指向的string，每个HasPtr对象都有自己的拷贝
    HasPtr(const HasPtr &p): ps(new string(*p.ps)),i(p.i){};
    Hasptr& operator=(const HasPtr &);
    ~HasPtr() { delete ps;}
private:
    string *ps;
    int i;
};

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps);//拷贝底层string
    delete ps; //释放旧内存
    ps = newp; //从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this; //返回本对象
}
```

当编写赋值运算符时，有两点需要记住：

* 如果将一个对象赋予它自身，赋值运算符必须能够正确工作。

* 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

当编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。 一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

### 行为像指针的类

令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。拷贝（或赋值）一个shared_ptr会拷贝（赋值)shared_ptr所指向的指针。shared_ptr类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，shared_ptr类负责释放资源。

若我们希望直接管理资源。在这种情况下，使用引用计数。
（将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。）

```c++
class HasPtr{
public:
    //构造函数分配新的string和新的计数器，将计数器置为1
    HasPtr(const string &s = string()):ps(new string(s)),i(0),use(new size_t(1)){};
    //拷贝构造函数拷贝所有三个数据成员，并递增计数器
    HasPtr(const HasPtr &p):ps(p.ps),i(p.i),use(p.use){++*use;}
    HasPtr& operator=(const HasPtr&);
    ~HasPtr();
private:
    string *ps;
    int i;
    size_t *use; //用来记录有多少个对象共享*ps的成员
}

HasPtr::~HasPtr()
{
    if (--*use == 0){
        delete ps;
        delete use;
    }
}

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    ++*rhs.use; //先递增右侧运算对象的引用计数（防止自身赋值）
    if(--*use == 0) //然后递减本对象的引用计数
    {
        delete ps; 
        delete use; 
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```

## 交换操作

为了交换里那个对象，我们需要进行一次拷贝和两次赋值。
```c++
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```
拷贝一个类值的HasPtr会分配一个新string并将其拷贝到HasPtr指向的位置。
理论上，这些内存分配是不必要的。我们更希望swap交换指针，而不是分配string的新副本。如：
```c++
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

### 编写自己的swap函数

```c++
class HasPtr{
    friend void swap(HasPtr&, HasPtr&);
    //  其他成员跟上面一样
};

inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps,rhs.ps); //交换指针而不是string数据
    swap(lhs.i,rhs.i);
}
```

### 在赋值运算符中是使用swap

定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝交换的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换。
```c++
//注意rhs是按值传递的（形参），意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs。
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    //交换左侧运算对象和局部变量rhs的内容
    swap(*this,rhs); //rhs现在指向本对象曾使用的内存
    return *this; //rhs被销毁，从而delete了rhs中的指针（曾内存被销毁）
}
```
> 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。

