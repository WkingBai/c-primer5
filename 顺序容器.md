# 顺序容器

### 1.顺序容器类型
|容器类型|作用|
|:----:|----|
|<div style="width : 100pt">vector|可变大小数组。支持快速访问。在尾部之外的位置插入或删除元素可能很慢。|
|deque|双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。|
|list|双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。|
|forward_list|单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。|
|array|固定大小数组。支持快速随机访问。不能添加或删除元素。|
|string|与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。|

* 顺序容器几乎可以保存任意类型，但某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但在构造时要提供一个元素初始化器。

    eg： 假设noDefault没有默认构造函数。
    ```c++
    vector<noDefault> v1(10,init); //init为元素初始化器
    ```

* forward_list 迭代器不支持递减运算符（--）。

### 2.容器定义和初始化
|初始化|含义|
|:----:|----|
|<div style="width : 150pt">C c|默认构造函数。如果c是一个array，则c中元素按默认方式初始化；否则c为空。|
|C c1(c2)<td rowspan = '2'>c1初始化为c2的拷贝。c1和c2必须是相同类型。（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于array类型，两者还必须具有相同大小）</td>
|C c1 = c2|
|C c{a,b,c...}<td rowspan = '2'>c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与c的元素类型相容。对于array类型，列表中元素数目必须等于或小于array的大小，任何遗漏的元素都进行值初始化。|
|C c = {a,b,c...}|
|C c(b,e)|c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与c的元素类型相容。（array不适用）|
|C seq(n)|seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的。(只能直接初始化)|
|C seq(n,t)|seq包含b个初始化为值t的元素。|

==只有顺序容器（不包括array）的结构函数才能接受大小参数==

* 将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。
当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换。
```c++
vector<const char*> articles = {'a','an','the'};
forward_list<string> words(articles.begin(),articles.end()); //const char* 可转换为 string类型。
deque<string> authlist(articles.begin(),articles.end());// √
```
* array定义时必须同时指定类型和大小。
```c++
array<int,42> 
array<string,10>::size_type j;
```
* array可进行拷贝或对象赋值操作。
```c++
int digit[10] = {0,1,2,...,9};
int cpy[10] = digit; //×，内置函数不支持

array<int,10> digits = {0,1,2,.....,9};
array<int,10> copy = digits;//√
```

### 3.容器赋值运算
|赋值运算|作用|
|:----:|----|
|<div style = " width : 150pt">c1 = c2|将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型。|
|c = {a,b,c...}|将c1中元素替换为初始化列表中元素拷贝。（array不适用）|
|swap(c1,c2)|交换c1和c2中元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快的多。|
|seq.assign(b,e)|将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素。|
|seq.assign(il)|将seq中的元素替换为初始化列表il中的元素|
|seq.assign(n,t)|将seq中的元素替换为n个值为t的元素。|

==assign操作不适用于关联容器和array==

* 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效。（容器类型为array和string的情况除外）

    * swap只是交换了两个容器的内部数据结构，可以保证在常数时间内完成。
    * 元素不会移动，意味着指向容器的迭代器，引用和指针在swap后依然有效，只是这些元素属于的容器不同了。
    * array.swap()后会真正交换它们的元素，所需时间与array中元素数目成正比。swap后，指针、引用和迭代器所绑定的元素保存不变。
    ==统一使用非成员的swap是一个好习惯==

### 4.向顺序容器添加元素
  
  |函数|作用|
  |:----:|----|
  |<div style="width:150pt"> c.push_back(t)<td rowspan = "2">在c的尾部创建一个值为t或由args创建的元素。返回void。</td>
  |c.emplace_back(args)|
  |c.push_front(t)<td rowspan="2">在c的头部创建一个值为t或由args创建的元素。返回void。</td>
  |c.emplace_front(args)|
  |c.insert(p,t)<td rowspan="2">在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器。</td>
  |c.emplace(p,args)|
  |c.insert(p,b,e)|将迭代器b和e指定范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器。若范围为空，则返回p。|
  |c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p。|
  |c.insert(p,il)|il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p。|

==这些操作会改变容器的大小；array不支持这些操作;
forward_list有自己专有版本的insert和emplace;
forward_list不支持push_back 和 emplace_back;==

* 向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。
* emplace_front、emplace、emplace_back函数采用参数传递，在容器管理的内存空间中直接创建对象。其函数的参数必须与元素类型的构造函数相匹配。
* push_front、insert、push_back采用拷贝，创建临时对象，并将其压入容器。
  
### 5.在顺序容器中访问元素
|函数|作用|
|:----:|----|
|<div style="width:100pt">c.back()|返回c中尾元素的引用。若c为空，函数行为未定义|
|c.front()|返回c中首元素的引用。若c为空，函数行为未定义|
|c[n]|返回c中下标为n的元素的引用，n是一个无符号整数。若n>=c.size(),则函数行为未定义。|
|c.at(n)|返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常。|

==at和下标操作只适用于string、vector、deque和array。
back不适用于forward_list。==

* 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。
* 访问成员函数返回的是引用。
  ```c++
  c.fornt() = 42; //将42赋予c中第一个元素
  ```
  但对于auto:
  ```c++
  auto v2 = c.back(); //v2不是引用，是c.back()的一个拷贝
  v2 = 0; //未改变c中元素

  auto &v2 = c.back();//是引用
  v2 = 0;//改变c中元素
  ```

### 6.在顺序容器删除元素
|函数|作用|
|:----:|-----|
|<div style="width:100pt">c.pop_back()|删除c中尾元素。若c为空，则函数行为未定义。函数返回void。|
|c.pop_front()|删除c中首元素。若c为空，则函数行为未定义。函数返回void。|
|c.erase(p)|删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义。|
|c.erase(b,e)|删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器。|
|c.clear()|删除c中的所有元素。返回void。|

* 向容器中添加/删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的错误。

  **向容器中添加元素:**
  *  vector 、string:
    若存储空间被重新分配：指向容器的迭代器、指针和引用都会失效。
    若存储空间未重新分配：指向插入位置之前元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的将会失效。
  *  deque：
    插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
  *  list 、 forward_list：
    指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

    **从容器中删除元素:**

  * list 、 forward_list:
    指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
  * deque：
    如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用和指针也会失效。
    如果删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响。
    如果删除首元素，不会受影响。
  * vector 、 string：
    指向被删元素之前元素的迭代器、引用和指针仍然有效。
    ==当我们删除元素时，尾后迭代器总是会失效==

* 如果在一个循环中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器。

```c++
  while(begin != v.end()){    }//每个添加/删除循环都重新计算end 
```

### 7.在forward_list中插入或删除元素
|函数|作用|
|:----:|----|
|<div style="width:150pt">lst.before_begin()<td rowspan="2">返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。cbefore_begin()返回一个const_iterator。</td>
|lst.cbefore_begin()|
|lst.insert_after(p,t)<td rowspan="4">在迭代器p之后的位置插入元素。t是一个对象，n是数量，b和e是表示范围的一对迭代器（b和e不能指向lst内），il是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义</td>
|lst.insert_after(p,n,t)|
|lst.insert_after(p,b,e)|
|lst.insert_after(p,il)|
|emplace_after(p,args)|使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。|
|lst.erase_after(p)<td rowspan="2">删除p指向的位置之后的元素，或删除从b之后直到（但不包含）e之间的元素。返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。|
|lst.erase_after(b,e)|

### 8.容器大小管理操作
|函数|作用|
|:----:|----|
|<div style="width:100pt">c.resize(n)|调整c的大小为n个元素。若n < s.size(),则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化。|
|c.resize(n,t)|调整c的大小为n个元素。任何新添加的元素都初始化为值t。|
|c.shrink_to_fit()|请将capacity()减少为与size()相同大小。|
|c.capacity()|不重新分配内存空间的话，c可以保存多少元素。|
|c.reserve(n)|分配至少能容纳n个元素的内存空间。|

==shrink_to_fit 只适用与 vector、string和deque。
capacity和reserve只适用于vector和string==

* reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。
* reserve改变capacity，但是只保证扩大会成功。如果需求小于或等于但钱容量，reserve什么也不做。
* shrink_to_fit也并不保证一定退回内存空间。